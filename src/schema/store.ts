
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { String, Int, BigInt, Float, ID, Bytes, Timestamp, Boolean } from '@sentio/sdk/store'
import { Entity, Required, One, Many, Column, ListColumn, AbstractEntity } from '@sentio/sdk/store'
import { BigDecimal } from '@sentio/bigdecimal'
import { DatabaseSchema } from '@sentio/sdk'







interface PoolVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  underlyingPoolAddress: String;
  underlyingTokenAddress: String;
  underlyingTokenDecimals: Int;
  receiptTokenAddress: String;
  receiptTokenDecimals: Int;
  receiptTokenSymbol: String;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("PoolVault")
export class PoolVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	underlyingPoolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("Int")
	underlyingTokenDecimals: Int

	@Required
	@Column("String")
	receiptTokenAddress: String

	@Required
	@Column("Int")
	receiptTokenDecimals: Int

	@Required
	@Column("String")
	receiptTokenSymbol: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: PoolVaultConstructorInput) {super()}
  
}


interface PositionVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  userAddress: String;
  liquidityPoolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenDecimals: Int;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("PositionVault")
export class PositionVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	liquidityPoolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("Int")
	underlyingTokenDecimals: Int

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: PositionVaultConstructorInput) {super()}
  
}


interface LPTokenEventVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  fromAddress: String;
  toAddress: String;
  poolAddress: String;
  underlyingTokenAddress: String;
  amount: BigDecimal;
  eventType: String;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("LPTokenEventVault")
export class LPTokenEventVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	fromAddress: String

	@Required
	@Column("String")
	toAddress: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	amount: BigDecimal

	@Required
	@Column("String")
	eventType: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: LPTokenEventVaultConstructorInput) {super()}
  
}


interface UserEventVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  userAddress: String;
  poolAddress: String;
  underlyingTokenAddress: String;
  amount: BigDecimal;
  amountUsd: BigDecimal;
  eventType: String;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("UserEventVault")
export class UserEventVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	amount: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUsd: BigDecimal

	@Required
	@Column("String")
	eventType: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: UserEventVaultConstructorInput) {super()}
  
}


interface IncentiveClaimVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  transactionSigner: String;
  userAddress: String;
  claimedTokenAddress: String;
  amount: BigDecimal;
  amountUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("IncentiveClaimVault")
export class IncentiveClaimVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	transactionSigner: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	claimedTokenAddress: String

	@Required
	@Column("BigDecimal")
	amount: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: IncentiveClaimVaultConstructorInput) {super()}
  
}


interface HourlyPoolSnapshotVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  liquidityPoolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("HourlyPoolSnapshotVault")
export class HourlyPoolSnapshotVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	liquidityPoolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: HourlyPoolSnapshotVaultConstructorInput) {super()}
  
}


interface DailyPoolSnapshotVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  liquidityPoolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("DailyPoolSnapshotVault")
export class DailyPoolSnapshotVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	liquidityPoolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: DailyPoolSnapshotVaultConstructorInput) {super()}
  
}


interface HourlyPositionSnapshotVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  userAddress: String;
  liquidityPoolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("HourlyPositionSnapshotVault")
export class HourlyPositionSnapshotVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	liquidityPoolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: HourlyPositionSnapshotVaultConstructorInput) {super()}
  
}


interface DailyPositionSnapshotVaultConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  strategyVaultContractAddress: String;
  userAddress: String;
  liquidityPoolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("DailyPositionSnapshotVault")
export class DailyPositionSnapshotVault extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	strategyVaultContractAddress: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	liquidityPoolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: DailyPositionSnapshotVaultConstructorInput) {super()}
  
}


interface PoolRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  poolAddress: String;
  poolSymbol: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenSymbol: String;
  underlyingTokenDecimals: Int;
  receiptTokenAddress: String;
  receiptTokenSymbol: String;
  receiptTokenDecimals: Int;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("PoolRecipe")
export class PoolRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	poolSymbol: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("String")
	underlyingTokenSymbol: String

	@Required
	@Column("Int")
	underlyingTokenDecimals: Int

	@Required
	@Column("String")
	receiptTokenAddress: String

	@Required
	@Column("String")
	receiptTokenSymbol: String

	@Required
	@Column("Int")
	receiptTokenDecimals: Int

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: PoolRecipeConstructorInput) {super()}
  
}


interface HourlyPoolSnapshotRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  poolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("HourlyPoolSnapshotRecipe")
export class HourlyPoolSnapshotRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: HourlyPoolSnapshotRecipeConstructorInput) {super()}
  
}


interface DailyPoolSnapshotRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  poolAddress: String;
  underlyingTokenIndex: Int;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigDecimal;
  underlyingTokenAmountUsd: BigDecimal;
  totalFeesUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
}
@Entity("DailyPoolSnapshotRecipe")
export class DailyPoolSnapshotRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("Int")
	underlyingTokenIndex: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	underlyingTokenAmount: BigDecimal

	@Required
	@Column("BigDecimal")
	underlyingTokenAmountUsd: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt
  constructor(data: DailyPoolSnapshotRecipeConstructorInput) {super()}
  
}


interface UserEventRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  eventType: String;
  userAddress: String;
  takerAddress: String;
  poolAddress: String;
  underlyingTokenAddress: String;
  amount: BigDecimal;
  amountUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("UserEventRecipe")
export class UserEventRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	eventType: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	takerAddress: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigDecimal")
	amount: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: UserEventRecipeConstructorInput) {super()}
  
}


interface IncentiveClaimRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  transactionSigner: String;
  userAddress: String;
  claimedTokenAddress: String;
  amount: BigDecimal;
  amountUsd: BigDecimal;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("IncentiveClaimRecipe")
export class IncentiveClaimRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	transactionSigner: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	claimedTokenAddress: String

	@Required
	@Column("BigDecimal")
	amount: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUsd: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: IncentiveClaimRecipeConstructorInput) {super()}
  
}


interface OfferRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  offerSide: Int;
  offerId: String;
  marketId: String;
  accountAddress: String;
  underlyingTokenAddress: String;
  incentiveTokenAddresses: Array<String>;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("OfferRecipe")
export class OfferRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("Int")
	offerSide: Int

	@Required
	@Column("String")
	offerId: String

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	accountAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@ListColumn("String!")
	incentiveTokenAddresses: Array<String>

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: OfferRecipeConstructorInput) {super()}
  
}


interface PositionRecipeConstructorInput {
  id: ID;
  chainId: Int;
  marketType: Int;
  marketId: String;
  accountAddress: String;
  underlyingTokenAddress: String;
  underlyingTokenAmount: BigInt;
  incentiveTokenAddresses: Array<String>;
  incentiveTokenAmounts: Array<BigInt>;
  blockNumber: BigInt;
  blockTimestamp: BigInt;
  transactionHash: String;
  logIndex: BigInt;
}
@Entity("PositionRecipe")
export class PositionRecipe extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	chainId: Int

	@Required
	@Column("Int")
	marketType: Int

	@Required
	@Column("String")
	marketId: String

	@Required
	@Column("String")
	accountAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("BigInt")
	underlyingTokenAmount: BigInt

	@Required
	@ListColumn("String!")
	incentiveTokenAddresses: Array<String>

	@Required
	@ListColumn("BigInt!")
	incentiveTokenAmounts: Array<BigInt>

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	blockTimestamp: BigInt

	@Required
	@Column("String")
	transactionHash: String

	@Required
	@Column("BigInt")
	logIndex: BigInt
  constructor(data: PositionRecipeConstructorInput) {super()}
  
}


const source = `type PoolVault @entity {
  id: ID! # chainId_marketType_marketId
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  underlyingPoolAddress: String!
  underlyingTokenAddress: String!
  underlyingTokenDecimals: Int!
  receiptTokenAddress: String!
  receiptTokenDecimals: Int!
  receiptTokenSymbol: String!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type PositionVault @entity {
  id: ID! # chainId_marketType_marketId_userAddress
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  userAddress: String!
  liquidityPoolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenDecimals: Int!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type LPTokenEventVault @entity {
  id: ID! # chainId_transactionHash_logIndex
  chainId: Int!
  marketType: Int!
  marketId: String!
  fromAddress: String!
  toAddress: String!
  poolAddress: String!
  underlyingTokenAddress: String!
  amount: BigDecimal!
  eventType: String!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type UserEventVault @entity {
  id: ID! # chainId_transactionHash_logIndex
  chainId: Int!
  marketType: Int!
  marketId: String!
  userAddress: String!
  poolAddress: String!
  underlyingTokenAddress: String!
  amount: BigDecimal!
  amountUsd: BigDecimal!
  eventType: String!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type IncentiveClaimVault @entity {
  id: ID! # chainId_transactionHash_logIndex
  chainId: Int!
  marketType: Int!
  marketId: String!
  transactionSigner: String!
  userAddress: String!
  claimedTokenAddress: String!
  amount: BigDecimal!
  amountUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type HourlyPoolSnapshotVault @entity {
  id: ID! # chainId_marketType_marketId_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  liquidityPoolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type DailyPoolSnapshotVault @entity {
  id: ID! # chainId_marketType_marketId_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  liquidityPoolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type HourlyPositionSnapshotVault @entity {
  id: ID! # chainId_marketType_marketId_userAddress_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  userAddress: String!
  liquidityPoolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type DailyPositionSnapshotVault @entity {
  id: ID! # chainId_marketType_marketId_userAddress_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  strategyVaultContractAddress: String!
  userAddress: String!
  liquidityPoolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type PoolRecipe @entity {
  id: ID! # chainId_marketType_marketId
  chainId: Int!
  marketType: Int!
  marketId: String!
  poolAddress: String!
  poolSymbol: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenSymbol: String!
  underlyingTokenDecimals: Int!
  receiptTokenAddress: String!
  receiptTokenSymbol: String!
  receiptTokenDecimals: Int!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type HourlyPoolSnapshotRecipe @entity {
  id: ID! # chainId_marketType_marketId_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  poolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type DailyPoolSnapshotRecipe @entity {
  id: ID! # chainId_marketType_marketId_timestampId
  chainId: Int!
  marketType: Int!
  marketId: String!
  poolAddress: String!
  underlyingTokenIndex: Int!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigDecimal!
  underlyingTokenAmountUsd: BigDecimal!
  totalFeesUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type UserEventRecipe @entity {
  id: ID! # chainId_transactionHash_logIndex
  chainId: Int!
  marketType: Int!
  marketId: String!
  eventType: String!
  userAddress: String!
  takerAddress: String!
  poolAddress: String!
  underlyingTokenAddress: String!
  amount: BigDecimal!
  amountUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type IncentiveClaimRecipe @entity {
  id: ID! # chainId_transactionHash_logIndex
  chainId: Int!
  marketType: Int!
  marketId: String!
  transactionSigner: String!
  userAddress: String!
  claimedTokenAddress: String!
  amount: BigDecimal!
  amountUsd: BigDecimal!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type OfferRecipe @entity {
  id: ID! # chainId_marketType_offerSide_offerId
  chainId: Int!
  marketType: Int!
  offerSide: Int!
  offerId: String!
  marketId: String!
  accountAddress: String!
  underlyingTokenAddress: String!
  incentiveTokenAddresses: [String!]!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}

type PositionRecipe @entity {
  id: ID! # chainId_marketType_marketId_userAddress
  chainId: Int!
  marketType: Int!
  marketId: String!
  accountAddress: String!
  underlyingTokenAddress: String!
  underlyingTokenAmount: BigInt!
  incentiveTokenAddresses: [String!]!
  incentiveTokenAmounts: [BigInt!]!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  logIndex: BigInt!
}
`
DatabaseSchema.register({
  source,
  entities: {
    "PoolVault": PoolVault,
		"PositionVault": PositionVault,
		"LPTokenEventVault": LPTokenEventVault,
		"UserEventVault": UserEventVault,
		"IncentiveClaimVault": IncentiveClaimVault,
		"HourlyPoolSnapshotVault": HourlyPoolSnapshotVault,
		"DailyPoolSnapshotVault": DailyPoolSnapshotVault,
		"HourlyPositionSnapshotVault": HourlyPositionSnapshotVault,
		"DailyPositionSnapshotVault": DailyPositionSnapshotVault,
		"PoolRecipe": PoolRecipe,
		"HourlyPoolSnapshotRecipe": HourlyPoolSnapshotRecipe,
		"DailyPoolSnapshotRecipe": DailyPoolSnapshotRecipe,
		"UserEventRecipe": UserEventRecipe,
		"IncentiveClaimRecipe": IncentiveClaimRecipe,
		"OfferRecipe": OfferRecipe,
		"PositionRecipe": PositionRecipe
  }
})
